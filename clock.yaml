# Define substitutions for the ESPHome configuration
substitutions:
  timezone: "Europe/London"
  button_gpio:
    hour: GPIO15
    minute: GPIO23
    zero: GPIO24
  display_gpio:
    sda: GPIO18
    scl: GPIO26
  rtc_gpio:
    sda: GPIO17
    scl: GPIO16
  can_gpio:
    int: GPIO27
    sck: GPIO25
    si: GPIO32
    so: GPIO12
    cs: GPIO04

# Enable the API for Home Assistant integration 
api:
  port: 6053
  batch_delay: 50ms
  encryption:
    key: !secret api_encryption_key
  reboot_timeout: 30min

# Define ESPHome
# On boot, read the time from the RTC
esphome:
  name: gt86
  on_boot:
    - priority: 200
      then:
        - ds1307.read_time:
            id: ds1307_time
        - logger.log: Time read by ds1307

# Define the ESP32 board type
esp32:
  board: mhetesp32minikit

# Setup WiFi
# If internet connected, will update RTC with NTP time
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "GT86"
    password: !secret ap_password

# Enable the web UI for debugging
web_server:

# Enable logging but for INFO only
# Setting to DEBUG will crash the ESP32 due to can bus logs
logger:
  level: INFO

# Define the SPI pins
spi:
  - id: can_spi
    clk_pin: ${can_gpio.sck}
    mosi_pin: ${can_gpio.si}
    miso_pin: ${can_gpio.so}

# Define the I2C pins
i2c:
  - id: oled
    sda: ${display_gpio.sda}
    scl: ${display_gpio.scl}
  - id: rtc
    sda: ${rtc_gpio.sda}
    scl: ${rtc_gpio.scl}

# Define the time platform
# Use NTP for time synchronization if we have internet and update the RTC
# Otherwise, use the RTC
time:
  - platform: sntp
    id: sntp_time
    timezone: ${timezone}
    servers:
      - 0.pool.ntp.org
      - 1.pool.ntp.org
      - 2.pool.ntp.org
    on_time_sync:
      then:
        - ds1307.write_time:
            id: ds1307_time
        - delay: 1s
        - ds1307.read_time: 
            id: ds1307_time
  - platform: ds1307
    id: ds1307_time
    i2c_id: rtc

# Load in XBM (binary images) images for the display 
image:
  - id: car
    file: "images/car.xbm"
    type: BINARY
  - id: logo
    file: "images/logo.xbm"
    type: BINARY

# Create sensors for the buttons
# Work in progress still
binary_sensor:
  - id: hour_button
    name: "Hour Button"
    platform: gpio
    pin:
      number: ${button_gpio.hour}
      inverted: true
      mode:
        input: true
        pullup: true
    on_press:
      then:
        - display.page.show_next: oled_display

# Define our font. Still looking for the perfect one
font:
  - id: font_small
    file: "blockblueprint.medium.ttf"
    size: 22
  - id: font_large
    file: "blockblueprint.medium.ttf"
    size: 22

# Define the display and build the pages
display:
  - platform: ssd1306_i2c
    model: "SSD1306 128x32"
    id: oled_display
    i2c_id: oled
    update_interval: 0.1s
    pages:
      - id: p_splash
        lambda: |-
          it.image(0, 0, id(car));
      - id: p_time
        lambda: |-
          if (id(ds1307_time).now().second % 2 == 0) {
            it.strftime(0, it.get_height() / 2, id(font_large), TextAlign::CENTER_LEFT, "%H:%M", id(ds1307_time).now());
          }else{
            it.strftime(0, it.get_height() / 2, id(font_large), TextAlign::CENTER_LEFT, "%H %M", id(ds1307_time).now());
          }

          it.image(it.get_width() - 32, 0, id(logo));
      - id: p_date
        lambda: |-
          it.strftime(it.get_width() / 2, it.get_height() / 2, id(font_small), TextAlign::CENTER, "%d/%m/%y", id(ds1307_time).now());

# Define the CAN bus
# Listens to CAN messages to capture things like RPM, Oil pressure, etc
# Work in progress - waiting for GT86
canbus:
  - platform: mcp2515
    cs_pin: ${can_gpio.cs}
    can_id: 4
    bit_rate: 500kbps
    # on_frame:
    # - can_id: 0x451
    #   then:
    #   - lambda: |-
    #       std::string b(x.begin(), x.end());
    #       ESP_LOGI("can id 0x451", "%s", &b[0] );
    